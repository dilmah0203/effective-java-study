### 인터페이스에 메서드 추가

- 자바 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다.
- 자바 8부터는 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만, 컴파일 요류의 위험이 사라진 것은 아니다.
- 디폴트 메서드를 선ㄴ언하면 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에 디폴트 구현이 쓰이게 된다.

### 자바 8 핵심 컬렉션 인터페이스

- 자바 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다.
    - 람다를 활용하기 위함
- 하지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하는 것은 어렵다.

```java
default boolean removeIf(Predicate<? super E>filter){
        Objects.requireNonNull(filter);
        boolean result=false;
        for(Iterator<E> it=iterator();it.hasNext();){
        if(filter.test(it.next())){
        it.remove();
        result=true;
        }
        }
        return result;
        }

```

- 이 코드는 범용적으로 구현되었지만, 현존하는 모든 Collection 구현체와 잘 어우러지는 것은 아니다.
    - 대표적인 예가 SyncronizedCollection
- 아파치 커먼즈 라이브러리의 이 클래스는 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공한다.
    - 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스
- 아파치의 SyncronizedCollection은 removeIf 메서드를 재정의하지 않고 있다.
- removeIf의 구현은 동기화에 관해 아무것도 모르므로 락 객체를 사용할 수 없다.
- SyncronizedCollection 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf를 호출하면
  ConcurrentModificationException이 발생하거나 다른 예기치 못한 결과로 이어질 수 있다.

### 자바 플랫폼 라이브러리에서의 예방 조치

- 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다.
- 하지만 자바 플랫폼에 속하지 않은 제 3의 기존 컬렉션 구현체들은 이런 언어 차원의 인터페이스 변화에 발맞춰 수정될 기회가 없었다.

### 디폴트 메서드

- 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다.
- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야 한다.
- 새로운 메서드를 만드는 경우라면 표준적인 메서드 구현을 제공하는데 아주 유용한 수단이다.
- 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님을 명심해야 한다.

### 세심한 주의가 필요한 인터페이스 설계

- 디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 커다란 위험도 딸려온다.
- 새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야 한다.
- 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 만들어봐야 한다.
- 인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.