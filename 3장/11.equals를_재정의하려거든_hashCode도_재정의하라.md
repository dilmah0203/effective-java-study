`equals`를 재정의한 클래스 모두에서 `hashCode`도 재정의해야 한다. 그렇지 않으면 `hashCode` 일반 규약을 어기게 되어 해당 클래스의
인스턴스를 `HashMap`이나 `HashSet`같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.

### 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

`equals`가 물리적으로 다른 두 객체를 논리적으로 같다고 할 때, `hashCode`는 서로 다른 값을 반환한다.

```java
Map<PhoneNumber, String> map=new HashMap<>();
        map.put(new PhoneNumber(707,888,5555),new Person("제니"));
```

이 코드에 `map.get(new PhoneNumber(707,888,5555))`를 실행하면 "제니"가 아닌 `null`을 반환한다.
`PhoneNumber` 클래스는 `hashCode를` 재정의하지 않았기 때문에, 논리적 동치인 두 객체가 서로 다른 해시코드를 반환하여 get 메서드는 엉뚱한 해시 버킷에 가서
객체를 찾으려 한 것이다.
`HashMap은` 해시코드가 서로 다른 엔트리끼리는 동치성 비교를 시도조차 않도록 최적화 되어있다.

```java // 사용 금지
@Override public int hashCode(){
        return 42;
        }
```

위 코드는 적법하게 구현했지만, 절대 사용해서는 안되는 코드이다. 모든 객체에게 똑같은 값만 내어주므로 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 연결리스트처럼 동작한다. 그
결과 평균 수행 시간이 O(1)인 해시테이블이 O(n)으로 느려져서, 도저히 쓸 수 없게 된다.

### 좋은 `hashCode`를 작성하는 간단한 요령

1. int 변수인 `result`를 선언한 후 값을 c로 초기화한다.
2. 해당 객체의 나머지 핵심 필드인 f 각각에 대해 다음 작업을 수행한다
    - 해당 필드의 해시코드 `c`를 계산한다.
        - 기본 타입 필드라면, `Type.hashCode(f)`를 수행한다. 여기서 Type은 해당 기본타입의 박싱 클래스다.
        - 참조 타입 필드면서, 이 클래스의 `equals` 메소드가 이 필드의 `equals`를 재귀적으로 호출하여 비교한다면, 이 필드의 `hashCode`를 재귀적으로
          호출한다.
        - 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 모든 원소가 핵심 원소라면 `Arrays.hashCode`를 사용한다.
    - 해시코드 `c`로 `result`를 갱신한다.

### 핵심 정리

`equals`를 재정의할 때는 `hashCode`도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다. 재정의한 `hashCode`는 `Object`
의 API 문서에 기술된 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다. `AutuValue` 프레임워크를 사용하면 `equals`
와 `hashCode`를 자동으로 만들어주며, IDE들도 이런 기능을 일부 제공한다.  